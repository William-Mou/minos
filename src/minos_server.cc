/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */
#include <string.h>
#include <pwd.h>
#include <errno.h>
#include <arpa/inet.h>
#include <rpc/pmap_clnt.h>

#include <vector>
#include <iostream>

#include <minos.h>
#include "serialize.h"

namespace {

template <class T> struct Traits { static const char* tname; };
template <> const char* Traits<struct passwd>::tname = "passwd";
template <> const char* Traits<struct group>::tname = "group";
template <> const char* Traits<struct spwd>::tname = "spwd";
template <> const char* Traits<const char*>::tname = "name";
template <> const char* Traits<unsigned>::tname = "id";

template <class Entry, class Param, class Result>
void getXXbyYY(
	const struct svc_req *rqstp,
    int (&function)(const Param, Entry*, char*, size_t, Entry**),
    const Param& param,
	void*& buffer,
	size_t& buflen,
	Result& result
) {
	char addrp[INET6_ADDRSTRLEN];
	auto& sock_addr = rqstp->rq_xprt->xp_raddr;
	const char* p = inet_ntop(sock_addr.sin_family, &sock_addr.sin_addr, addrp, INET6_ADDRSTRLEN);
	if (p == NULL) {
		p = "???";
	}
	std::cout << "GET " << Traits<Entry>::tname << " BY " << Traits<Param>::tname << ":" << param << " FROM " << p << std::endl;
	if (buflen == 0) {
		buffer = malloc(1024);
		if (buffer == 0) {
			result.status = MINOS_SERVER_ERROR;
			return;
		}
		buflen = 1024;
	}
	Entry entry;
	Entry* entryp;
	while (true) {
		int retval = function(param, &entry, (char*)buffer, buflen, &entryp);
		if (entryp) {
			result.status = MINOS_SUCCESS;
			minos::serialize(entry, result.entry);
			return;
		} else if (retval == 0) {
			result.status = MINOS_NOTFOUND;
			return;
		} else if (retval == ERANGE) {
			void* realloc_result = realloc(buffer, buflen * 2);
			if (not realloc_result) {
				result.status = MINOS_SERVER_ERROR;
				return;
			}
			buffer = realloc_result;
			buflen *= 2;
			continue;
		} else {
			result.status = MINOS_SERVER_ERROR;
			return;
		}
	}
}

template <class Entry, class MinosEntry, class Result>
void getXXAll(
	const struct svc_req *rqstp,
    Entry* (&getXXent)(),
    void (&setXXent)(),
    void (&endXXent)(),
	std::vector<MinosEntry>& storage,
	Result& result
) {
	(void)rqstp;
	for (auto& minos_entry: storage) {
		minos::free_copy(minos_entry);
	}

	setXXent();
	Entry* entry;
	errno = 0;
	while (true) {
		entry = getXXent();
		if (not entry) {
			if (errno) {
				result.status = MINOS_SERVER_ERROR;
				return;
			}
			result.status = MINOS_SUCCESS;
			break;
		}
		storage.emplace_back();
		minos::serialize_copy(*entry, storage.back());
	}
	endXXent();
	result.list.list_len = storage.size();
	result.list.list_val = storage.data();
}

}

extern "C" {

minos_passwd_result *
minos_getpwnam_1_svc(char *name,  struct svc_req *rqstp)
{
	static minos_passwd_result  result;
	static void* buffer = 0;
	static size_t buflen = 0;
	getXXbyYY(rqstp, getpwnam_r, (const char*)name, buffer, buflen, result);
	return &result;
}

minos_passwd_result *
minos_getpwuid_1_svc(uint32_t uid,  struct svc_req *rqstp)
{
	static minos_passwd_result  result;
	static void* buffer = 0;
	static size_t buflen = 0;
	getXXbyYY(rqstp, getpwuid_r, uid, buffer, buflen, result);
	return &result;
}

minos_passwd_list_result *
minos_getpwall_1_svc(struct svc_req *rqstp)
{
	static minos_passwd_list_result  result;
	static std::vector<minos_passwd> storage;
	getXXAll(
		rqstp,
		getpwent,
		setpwent,
		endpwent,
		storage,
		result
	);
	return &result;
}

minos_group_result *
minos_getgrnam_1_svc(char *name,  struct svc_req *rqstp)
{
	static minos_group_result  result;
	static void* buffer = 0;
	static size_t buflen = 0;
	getXXbyYY(rqstp, getgrnam_r, (const char*)name, buffer, buflen, result);
	return &result;
}

minos_group_result *
minos_getgrgid_1_svc(uint32_t gid,  struct svc_req *rqstp)
{
	static minos_group_result  result;
	static void* buffer = 0;
	static size_t buflen = 0;
	getXXbyYY(rqstp, getgrgid_r, gid, buffer, buflen, result);
	return &result;
}

minos_group_list_result *
minos_getgrall_1_svc(struct svc_req *rqstp)
{
	static minos_group_list_result  result;
	static std::vector<minos_group> storage;
	getXXAll(
		rqstp,
		getgrent,
		setgrent,
		endgrent,
		storage,
		result
	);
	return &result;
}

minos_shadow_result *
minos_getspnam_1_svc(char *name,  struct svc_req *rqstp)
{
	static minos_shadow_result  result;
	static void* buffer = 0;
	static size_t buflen = 0;
	getXXbyYY(rqstp, getspnam_r, (const char*)name, buffer, buflen, result);
	return &result;
}

minos_shadow_list_result *
minos_getspall_1_svc(struct svc_req *rqstp)
{
	static minos_shadow_list_result  result;
	static std::vector<minos_shadow> storage;
	getXXAll(
		rqstp,
		getspent,
		setspent,
		endspent,
		storage,
		result
	);
	return &result;
}

void minos_1(struct svc_req *rqstp, register SVCXPRT *transp);

}


int main() {
	SVCXPRT *transp;

	pmap_unset(MINOS, MINOSVERSION);

	transp = svcudp_create(RPC_ANYSOCK);
	if (transp == NULL) {
		fprintf (stderr, "cannot create udp service.\n");
		exit(1);
	}
	if (!svc_register(transp, MINOS, MINOSVERSION, minos_1, IPPROTO_UDP)) {
		fprintf (stderr, "unable to register (MINOS, MINOSVERSION, udp).\n");
		exit(1);
	}

	svc_run ();
	fprintf (stderr, "svc_run returned\n");
	exit (1);
	/* NOTREACHED */
}
